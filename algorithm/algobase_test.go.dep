package algorithm

import (
	"testing"

	"github.com/jhzhu89/golib/iterator"
	"github.com/stretchr/testify/assert"
)

type intSlice struct {
	data []Value
}

func (s *intSlice) Insert(iter intSliceIter, val Value) intSliceIter {
	var i = iter.i
	s.data = append(s.data, nil)
	copy(s.data[i+1:], s.data[i:])
	s.data[i] = val
	iter.i++
	return iter
}

func (s *intSlice) PushBack(val Value) {
	s.data = append(s.data, val)
}

func (s *intSlice) PushFront(val Value) {
	var size = len(s.data)
	s.data = append(s.data, nil)
	copy(s.data[1:], s.data[:size])
	s.data[0] = val
}

type intSliceIter struct {
	data *[]Value
	i    int
}

func (it *intSliceIter) Get() Value {
	return (*it.data)[it.i]
}

func (it *intSliceIter) Set(val Value) {
	(*it.data)[it.i] = val
}

func (it *intSliceIter) Equal(r interface{}) bool {
	return it.i == r.(*intSliceIter).i
}

func (it *intSliceIter) Next() {
	it.i++
}

func (it *intSliceIter) Prev() {
	it.i--
}

func (it *intSliceIter) CanMultiPass() {}

func TestCopy(t *testing.T) {
	var is1 = new(intSlice)
	is1.data = make([]Value, 0)

	var begin = intSliceIter{&is1.data, 0}
	is1.Insert(begin, 1)
	is1.Insert(begin, 2)
	is1.Insert(begin, 3)
	is1.Insert(begin, 4)
	assert.Equal(t, &intSlice{[]Value{4, 3, 2, 1}}, is1)

	var end = intSliceIter{&is1.data, len(is1.data)}

	t.Run(`InsertIterator`, func(t *testing.T) {
		t.Run(`Empty`, func(t *testing.T) {
			var is2 = new(intSlice)
			is2.data = []Value{}
			var iit = iterator.NewInsertIterator(is2, intSliceIter{&is2.data, 0})
			Copy(begin, end, *iit)
			assert.Equal(t, &intSlice{[]Value{4, 3, 2, 1}}, is2)
		})

		t.Run(`Begin`, func(t *testing.T) {
			var is2 = new(intSlice)
			is2.data = []Value{5}
			var iit = iterator.NewInsertIterator(is2, intSliceIter{&is2.data, 0})
			Copy(begin, end, *iit)
			assert.Equal(t, &intSlice{[]Value{4, 3, 2, 1, 5}}, is2)
		})

		t.Run(`Middle`, func(t *testing.T) {
			var is2 = new(intSlice)
			is2.data = []Value{5, 6}
			var iit = iterator.NewInsertIterator(is2, intSliceIter{&is2.data, 1})
			Copy(begin, end, *iit)
			assert.Equal(t, &intSlice{[]Value{5, 4, 3, 2, 1, 6}}, is2)
		})

		t.Run(`End`, func(t *testing.T) {
			var is2 = new(intSlice)
			is2.data = []Value{5, 6}
			var iit = iterator.NewInsertIterator(is2, intSliceIter{&is2.data, 2})
			Copy(begin, end, *iit)
			assert.Equal(t, &intSlice{[]Value{5, 6, 4, 3, 2, 1}}, is2)
		})
	})

	t.Run(`BackInsertIterator`, func(t *testing.T) {
		var is2 = new(intSlice)
		is2.data = []Value{5, 6}
		var bit = iterator.NewBackInsertIterator(is2)
		Copy(begin, end, *bit)
		assert.Equal(t, &intSlice{[]Value{5, 6, 4, 3, 2, 1}}, is2)
	})

	t.Run(`FrontInsertIterator`, func(t *testing.T) {
		var is2 = new(intSlice)
		is2.data = []Value{5, 6}
		var fit = iterator.NewFrontInsertIterator(is2)
		Copy(begin, end, *fit)
		assert.Equal(t, &intSlice{[]Value{1, 2, 3, 4, 5, 6}}, is2)
	})

	t.Run(`OutputIterator`, func(t *testing.T) {
		var is = new(intSlice)
		is.data = make([]Value, 0)

		var begin = intSliceIter{&is.data, 0}
		is.Insert(begin, 1)
		is.Insert(begin, 2)
		is.Insert(begin, 3)
		is.Insert(begin, 4)
		assert.Equal(t, &intSlice{[]Value{4, 3, 2, 1}}, is)
		var end = intSliceIter{&is.data, 2}

		var it = begin
		it.i = 4
		var newit = CopyBackward(begin, end, it)
		assert.Equal(t, &intSlice{[]Value{4, 3, 4, 3}}, is)
		assert.Equal(t, newit.(intSliceIter).i, 3)
	})
}
